---
title: "CIを改善し続けて見えてきた、高速で安定したCIを実現するためのTips"
emoji: "😽"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["CI", "e2e"]
published: false
---

# イントロダクション

私の所属する組織ProductTeamではTDDを実践しており、すべての開発においてWeb-E2E、Module-E2E、UnitTestなどを書き実装を進めています。必ずCIを通してデプロイするという環境のため、CIの高速化と安定化は非常に重要な課題です。

また、組織にはチームシャッフル[^1]という文化があり、数ヶ月～1年程度でチームの構成が変わります。そのため私はこれまでに複数のチームでCIを改善する機会がありました。
それらのプロジェクトでは、数年もののE2Eプロジェクトだったり、まだ小規模なもの、それぞれ課題や環境が異なっていました。

今回はその中で得た知見をまとめ、CIの高速化と安定化を実現するためのTipsを紹介します。

:::message
ProductTeamでは[Selenide](https://selenide.org/)や[Gauge](https://gauge.org/index.html)を用いたE2Eテストの実行環境を構築していることがほとんどなので、E2EテストのTipsはそれらを前提にしていることが多いことをご了承ください。
:::

[^1]: チームの構成を定期的に変更することで、チーム間の知識共有を促進し、エンジニアの挑戦の機会を生み出す仕組みです。

## CIの高速化と安定化の重要性

CIにかかる時間が長いと、開発者はCIの結果を待つ時間が長くなり、開発の効率が落ちたり、顧客へのデリバリーが遅れたりします。

開発生産性の指標であるFourKeysの1つにも "コードの変更から本番環境で稼働するまでの時間「**リードタイム**」" があり、CIにかかる時間はこの指標にも大きく影響します。
CIの不安定さがこのリードタイムに影響することは、想像に難くありません。

もちろん指標を追い求めているだけではありませんが、ユーザーに価値をデリバリーし続けていくためには、CIの高速化と安定化は重要です。

# テストの安定化：基本原則と戦略

先にも述べたように、テストの不安定さがあってはCIの速度を上げることはできません。
既存のCIの改善に着手する場合、テストの安定化を優先して改善することをおすすめします。

## テストフレームワークを理解し上手く利用する

ものすごくシンプルで基本的な話ですが、テストフレームワークの理解と利用方法を把握していることは、テストの安定化には必須です。
Selenideなどのテストフレームワークは、テストの安定化に役立つ機能を提供しています。

<!-- textlint-disable -->
:::details Selenideの機能例
<!-- textlint-enable -->
- 自動的な要素の待機： 要素が見つかるまで自動的に待機する
- Ajaxサポート： Ajaxリクエストの完了を自動的に待機する
- 集成されたアサーション：要素の状態を検証するためのアサーション（Hrefなど）
:::

Selenideに関しては、別記事にもしていますので、そちらも参考にしてください。
[Selenideを利用するときに心がけること](https://zenn.dev/ragnar1904/articles/selenide-essentials)

CypressやPlaywrightなどのテストフレームワークも同様な機能を備えています。
[CypressのImplicit Assertions](https://docs.cypress.io/guides/core-concepts/retry-ability#Implicit-Assertions)

:::message
Web-E2E以外の文脈でも、テストフレームワークの理解はやはり重要です。
最近では[Testing Library](https://testing-library.com/)などでComponentTestを行うことが多くなってきていますが、AriaやRoleなどの概念の理解や、非同期処理の待機方法などを理解すべきことは多いです。
:::

## シンプルなテストコードの維持とその重要性

私の経験では、テストコードをシンプルに保つことは意外と難しいです。

Selenide + Gaugeという構成では、Testを記述したSpecファイルと、実際の処理を記述したStepがあるのですが、Stepはそれぞれただの関数群です。
そのため、気を抜くとStepにロジックが増えてしまい、テストコードが複雑になってしまいます。

<!-- TODO: ここに例をいろいろとかきたい -->

ここ最近では[playtest](https://github.com/uzabase/playtest)という、一般的なStepを定義したものをライブラリ化して利用しています。例えば、HTTPリクエスト、BodyやStatusなどのアサート、Mockへのリクエスト検証などです。
Module-E2Eなどであれば、基本的なリクエスト/アサートはplaytestに含まれているため、シンプルなStepの組み合わせだけでE2Eを記述できるようになっています。


#### Playtestを利用した例
以下のStepはすべてPlaytestに含まれており、Stepを実装しなくてもテストを実装できるようになっています。

```markdown
## GETリクエスト
* URL"/"にGETリクエストを送る
* レスポンスステータスコードが"200"である
* レスポンスヘッダーに"x-example-header"が存在し、その値が"example1"である
* レスポンスのJSONの"$.message"が文字列の"Hello Playtest-Gauge-Rest!"である
```

## 確実なデータセットアップ

ElasticSearchなどのDatabaseを利用したテストを行う場合に多いのですが、データセットアップには注意が必要です。

ElasticSearchの場合、fixtureをindexする際にそのデータがindexに反映される時間がかかります。
そのため、以下の方法で回避する必要があります。

- Index Refresh APIを利用する
    更新のリクエストをしたあと、[Refresh API](https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-refresh.html)を叩くことで即座にindex反映される。
- Indexの更新時にRefreshを行う
    クエリパラメータに`?refresh`を指定し更新リクエストを送ると、index反映を待ってレスポンスが帰ってくるようになる。
- Index Refresh Intervalを短くする
    `refresh_interval`を短くすることで、indexに反映されるまでの時間を短くできる。Productionでは反映すべきではないため、管理が少し煩雑になる。

このあたりの情報は、知らないとハマることが多いので、ぜひ覚えておくことをおすすめします。


## CDC（Consumer Driven Contract）の利用によるモジュール間の依存性の解消

私たちのプロダクトはマイクロサービスで構成されており、それぞれのサービスは独立して開発されています。
各マイクロサービスの中には、いろんなモジュールから利用されるAPIもあります。あるAPIがいろんな環境で利用されるようになると、そのAPIの変更の影響範囲を把握することが難しくなります。

<!-- TODO: ここに図 -->

そこで、呼び出すモジュール（Consumer）の開発者が、自分のモジュールが利用するAPI（Provider）の仕様を「Contract」として定義します。
ConsumerはContractを前提にモック化してテストを実施し、ProviderはContractが守られていることを示すテストを実施します。これにより振る舞いを保持しながら双方が独立して開発を進めることができます。

<!-- TODO: ここに図 -->

このようなテスト手法を**Consumer Driven Contract** (CDC)と呼びます。

CDCはテストの安定化や高速化を目的としたものではありませんが、モックを利用できることで高速化にも効果があります。
依存するモジュールのソースのチェックアウトやビルド、デプロイなどを待つ必要がなくなる上、自分が知らないところで起きた修正によってテストが失敗することもありません。
マイクロサービスにおける開発では、必ず利用したいテスト手法です。

:::message
ProductTeamでは、WiremockへのStubをもとにContractを生成する[play-cdc](https://github.com/uzabase/play-cdc)を利用して、効率的にCDCを行っています。
:::


# テストの高速化：効果的なテクニック

ここからは具体的にテストの高速化について紹介していきます。

## テストの並列実行

テストの並列実行は、テストの高速化において最も効果的な手法です。
私が実際に取り組んだのは、テストの実行のみを並列化するものと、テスト環境自体を並列化するものの2つです。

### 単一環境におけるテストの並列実行

テストフレームワークにはテストの並列実行をサポートしているものが多く、UnitTestなどではデフォルトで並列実行されるものもあります。

しかしE2Eの場合、テストの並列実行はテスト環境の状態を考慮しながら行う必要があります。
具体的な例を考えてみましょう。DBへの書き込みが発生するケースでは、同時に流れているテストが影響しテストは失敗します。

<!-- TODO： ここに図 -->

テスト環境が1つの場合、Read-onlyのテストは並列実行しても問題ないので、Writeが発生するテストと分割することで並列実行できます。

#### Read-onlyのテストとWriteが発生するテストの分割

```shell
docker-compose up -d  # テスト環境の起動
mvn gauge:execute -Dtags="ReadOnly" -DinParallel=true # ReadOnlyとタグが付いたテストを並列実行
mvn gauge:execute -Dtags="!ReadOnly"  # ReadOnly以外のテストを直列実行
```

:::message
このとき、Read-onlyのTestのデータセットアップはTest全体が流れる前の一度だけになります。`BeforeEach`で毎回セットアップはできません。
一方でWriteが発生するテストのデータセットアップは、テストごとに行う必要があります。
:::

#### この手法のメリット
- どのCI環境でも比較的簡単に実装できます。

#### この手法のデメリット
- この手法の並列実行をあとから導入することはかなり難しいです。Read-onlyのTestを特定し、それらが依存しているデータを特定しセットアップすることを続ける必要があります。
- 並列実行できるテストが限られてしまうため、並列実行の効果が限定的です。
- Read-onlyなものとそうでないものでデータセットアップのサイクルが変わるので、少し煩雑です。

### 複数環境でのテストの並列実行

Test環境自体を複数にし、テストを分割することで並列実行を行うこともできます。

## WebDriverセッションの再利用と起動のオーバーヘッド削減
## ログイン要否によるテスト分類とセッション管理の最適化


# 結論

## 記事の要点のまとめ
## CIの高速化・安定化がもたらす長期的な効果についての強調